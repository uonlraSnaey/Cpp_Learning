[基本语法]
[注释]
[数据类型]
[变量类型]
[变量作用域]
[常量]
[修饰符类型]
[存储类]
************
### C++基本语法
C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。

- **对象-**： 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -**  ：类可以定义为描述对象行为/状态的模板。
- **方法 -** ： 从基本上说，一个方法表示一种行为。
-  **即时变量 -**  :每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

#### C++ 程序结构
看下面这段简单代码：
```
#include <iostream> using namespace std;
// main() 是程序开始执行的地方 
int main() 
{
cout << "Hello World";
// 输出 Hello World
return 0;
}
```
- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **< iostream >**。
- 下一行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。
- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。
- 下一行 **int main()** 是主函数，程序从这里开始执行。
- 下一行 **cout << "Hello World";** 会在屏幕上显示消息 "Hello World"。
- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。

#### 编译 & 执行 C++ 程序
- 打开一个文本编辑器，添加上述代码。
- 保存文件为 hello.cpp。
- 打开命令提示符，进入到保存文件所在的目录。
- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。
- 现在，键入 ' a.out' 来运行程序。

#### 三字符组

用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。

![[Pasted image 20230608204248.png]]
如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。

### 注释
C++ 注释一般有两种：

- // - 一般用于单行注释。注释以 // 开始，直到行末为止
    
- /* ... * / - 一般用于多行注释。

### C++ 数据类型
需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。

#### 基本的内置类型
七种基本的 C++ 数据类型：
![[Pasted image 20230608205108.png]]

==wchar_t==:  typedef short int wchar_t;
即wchar_t 实际上的空间是和 short int 一样。

一些基本类型可以使用一个或多个类型修饰符进行修饰：

- signed
- unsigned
- short
- long

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。
**注意** ：
- 不同系统会有所差异，一字节为 8 位。
- 默认情况下，int、short、long都是带符号的，即 signed。
- long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节
![[Pasted image 20230608205333.png]]

31位系统与64位系统的存储大小的差别:
![[Pasted image 20230608205532.jpg]]

#### typedef 声明
您可以使用 **typedef** 为一个已有的类型取一个新的名字。
```
typedef type newname;
```
下面的语句会告诉编译器，feet 是 int 的另一个名称：
```
typedef int feet;
```
现在，下面的声明是完全合法的，它创建了一个整型变量 distance：
```
feet distance;
```

#### 枚举类型
枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：

```
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
```
如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。

```
enum color { red, green, blue } c;
c = blue;
```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推
也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。

例如，在下面的枚举中，**green** 的值为 5。
```
enum color { red, green=5, blue };
```
在这里，**blue** 的值为 6，因为默认情况下，==每个名称都会比它前面一个名称大 1==，但 red 的值依然为 0。

#### 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。

C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。

##### 静态转换（Static Cast）
静态转换是将一种数据类型的值强制转换为另一种数据类型的值。
==静态转换不进行任何运行时类型检查==，因此可能会导致运行时错误。
```
int i = 10;  
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```

##### 动态转换（Dynamic Cast）
动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。
动态转换==在运行时进行类型检查==，如果不能进行转换则返回空指针或引发异常。
```
class Base {};  
class Derived : public Base {};  
Base* ptr_base = new Derived;  
Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
```

##### 常量转换（Const Cast）
常量转换用于将 const 类型的对象转换为非 const 类型的对象。
常量转换只能用于转换掉 const 属性，不能改变对象的类型。
```
const int i = 10;  
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

##### 重新解释转换（Reinterpret Cast）
重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。
重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。
```
int i = 10;  
float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
```

### C++ 变量类型

变量并不是程序可以操作的存储区的名称。
C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。（大小写敏感）

![[Pasted image 20230610180154.png]]

C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等

#### C++ 中的变量定义
变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。
![[Pasted image 20230610180229.png]]

```
type variable_name = value;
```

**type** 必须是一个有效的 C++ 数据类型,可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成。


> [!NOTE] 带有静态存储持续时间的变量
> 带有静态存储持续时间的变量是指在程序的整个运行过程中都存在的变量。这些变量在它们首次初始化时分配内存，并且只在程序结束时释放。它们被存储在静态存储区域，而不是在函数的栈帧中。
> 
> 静态局部变量（Static Local Variables）、静态全局变量（Static Global Variables）

```
extern int a, b;
//关键字 `extern` 的作用是告诉编译器这些变量是在其他地方定义的，而不是在当前文件中定义的。它用于声明外部变量,以便在当前文件中使用而不需要重新定义它们。
```

#### C++ 中的左值（Lvalues）和右值（Rvalues）

C++ 中有两种类型的表达式：

- 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。==左值可以出现在赋值号的左边或右边。==
- 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，==右值可以出现在赋值号的右边，但不能出现在赋值号的左边。==

### 变量作用域


> [!NOTE] Note
> 变量的作用域是指在程序中可以访问和使用该变量的区域或范围。作用域规定了变量的可见性和生命周期。

一般来说有三个地方可以定义变量：

- 在函数或一个代码块内部声明的变量，称为**局部变量**。
- 在函数参数的定义中声明的变量，称为**形式参数**。
- 在所有函数外部声明的变量，称为**全局变量**。

作用域是程序的一个区域，变量的作用域可以分为以下几种：
- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。
```
#include <iostream>  
  
class MyClass {  
public:  
    static int class_var;  // 类作用域变量  
};  
  
int MyClass::class_var = 30;  
  
int main() {  
    std::cout << "类变量: " << MyClass::class_var << std::endl;  
    return 0;  
}
```
MyClass 类中声明了一个名为 class_var 的类作用域变量。可以使用类名和作用域解析运算符 :: 来访问这个变量。

#### 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，定义全局变量时，系统会自动初始化为下列值：
![[Pasted image 20230610181749.png]]

### C++ 常量

常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。
常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

#### 整数常量
前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。
整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

#### 浮点常量
浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

> [!NOTE] Tips
> 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。

```
3.14159 // 合法的 
314159E-5L // 合法的 
510E // 非法的：不完整的指数 
210f // 非法的：没有小数或指数 
.e55 // 非法的：缺少整数或分数
```

#### 布尔常量
flase - 真
true  - 假

> [!NOTE] Tips
> 不应把 true 的值看成 1，把 false 的值看成 0。

#### 字符常量
字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个==宽字符常量==（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个==窄字符常量==（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。
字符常量可以是一个普通的字符（例如 'x'）、一个转义序列（例如 '\t'），或一个通用的字符（例如 '\u02C0'）。

#### 字符串常量
字符串字面值或常量是括在双引号 "" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

可以使用 \ 做分隔符，把一个很长的字符串常量进行分行。

```
#include <iostream>  
#include <string>  
using namespace std;  
  
int main() {  
    string greeting = "hello, runoob";  
    cout << greeting;  
    cout << "\n";     // 换行符  
    string greeting2 = "hello, \  
                       runoob";  
    cout << greeting2;  
    return 0;  
}
```

#### 定义常量

在 C++ 中，有两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

#####  define 预处理器
```
#define identifier value
//
#define LENGTH 10
```
##### const 关键字
```
const type variable = value;
//
const int LENGTH = 10;
```

通常把常量定义为大写字母形式，是一个很好的编程实践。

### C++ 修饰符类型

C++ 允许在 **char、int 和 double** 数据类型前放置修饰符。
下面列出了数据类型修饰符：
- signed：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。
- unsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。
- short：表示变量的范围比 int 更小。short int 可以缩写为 short。
- long：表示变量的范围比 int 更大。long int 可以缩写为 long。
- long long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。
- float：表示单精度浮点数。
- double：表示双精度浮点数。
- bool：表示布尔类型，只有 true 和 false 两个值。
- char：表示字符类型。
- wchar_t：表示宽字符类型，可以存储 Unicode 字符。

修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。
这些修饰符也可以组合使用，修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。

#### C++ 中的类型限定符

![[Pasted image 20230610192230.png]]

cosnst:
```
const int NUM = 10;/ 定义常量 NUM，其值不可修改

volatile: 
volatile int num = 20; // 定义变量 num，其值可能会在未知的时间被改变

```

mutable：
![[Pasted image 20230610192626.png]]
static:
```
void example_function() {
    static int count = 0; // static 关键字使变量 count 存储在程序生命周期内都存在
    count++;
}
```
regiester:
```
void example_function(register int num) {
    // register 关键字建议编译器将变量 num 存储在寄存器中
    // 以提高程序执行速度
    // 但是实际上是否会存储在寄存器中由编译器决定
}
```

### C++存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。
 C++ 程序中可用的存储类：
- auto-声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。
	
- register-用于定义存储在寄存器中而不是 RAM 中的局部变量。
	
- static-指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。
	
- extern-用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。
	
- mutable-仅适用于类的对象，它允许对象的成员替代常量。
	
- thread_local (C++11)-声明的变量仅可在它在其上创建的线程上访问。

从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。








