### C++基本语法
C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。

- **对象-**： 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。
- **类 -**  ：类可以定义为描述对象行为/状态的模板。
- **方法 -** ： 从基本上说，一个方法表示一种行为。
- - **即时变量 -**  :每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。

#### C++ 程序结构
看下面这段简单代码：
```
#include <iostream> using namespace std;
// main() 是程序开始执行的地方 
int main() 
{
cout << "Hello World";
// 输出 Hello World
return 0;
}
```
- C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **< iostream >**。
- 下一行 **using namespace std;** 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。
- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。
- 下一行 **int main()** 是主函数，程序从这里开始执行。
- 下一行 **cout << "Hello World";** 会在屏幕上显示消息 "Hello World"。
- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。

#### 编译 & 执行 C++ 程序
- 打开一个文本编辑器，添加上述代码。
- 保存文件为 hello.cpp。
- 打开命令提示符，进入到保存文件所在的目录。
- 键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。
- 现在，键入 ' a.out' 来运行程序。

#### 三字符组

用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。

![[Pasted image 20230608204248.png]]
如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。

### 注释
C++ 注释一般有两种：

- // - 一般用于单行注释。注释以 // 开始，直到行末为止
    
- /* ... * / - 一般用于多行注释。

### C++ 数据类型
需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。

#### 基本的内置类型
七种基本的 C++ 数据类型：
![[Pasted image 20230608205108.png]]

==wchar_t==:  typedef short int wchar_t;
即wchar_t 实际上的空间是和 short int 一样。

一些基本类型可以使用一个或多个类型修饰符进行修饰：

- signed
- unsigned
- short
- long

下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。
**注意** ：
- 不同系统会有所差异，一字节为 8 位。
- 默认情况下，int、short、long都是带符号的，即 signed。
- long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节
![[Pasted image 20230608205333.png]]

31位系统与64位系统的存储大小的差别:
![[Pasted image 20230608205532.jpg]]

#### typedef 声明
您可以使用 **typedef** 为一个已有的类型取一个新的名字。
```
typedef type newname;
```
下面的语句会告诉编译器，feet 是 int 的另一个名称：
```
typedef int feet;
```
现在，下面的声明是完全合法的，它创建了一个整型变量 distance：
```
feet distance;
```

#### 枚举类型
枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓"枚举"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。
创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：

```
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
```
如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。

```
enum color { red, green, blue } c;
c = blue;
```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推
也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。

例如，在下面的枚举中，**green** 的值为 5。
```
enum color { red, green=5, blue };
```
在这里，**blue** 的值为 6，因为默认情况下，==每个名称都会比它前面一个名称大 1==，但 red 的值依然为 0。

#### 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。

C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。

##### 静态转换（Static Cast）
静态转换是将一种数据类型的值强制转换为另一种数据类型的值。
==静态转换不进行任何运行时类型检查==，因此可能会导致运行时错误。
```
int i = 10;  
float f = static_cast<float>(i); // 静态将int类型转换为float类型
```

##### 动态转换（Dynamic Cast）
动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。
动态转换==在运行时进行类型检查==，如果不能进行转换则返回空指针或引发异常。
```
class Base {};  
class Derived : public Base {};  
Base* ptr_base = new Derived;  
Derived* ptr_derived = dynamic_cast<Derived*>(ptr_base); // 将基类指针转换为派生类指针
```

##### 常量转换（Const Cast）
常量转换用于将 const 类型的对象转换为非 const 类型的对象。
常量转换只能用于转换掉 const 属性，不能改变对象的类型。
```
const int i = 10;  
int& r = const_cast<int&>(i); // 常量转换，将const int转换为int
```

##### 重新解释转换（Reinterpret Cast）
重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。
重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。
```
int i = 10;  
float f = reinterpret_cast<float&>(i); // 重新解释将int类型转换为float类型
```
